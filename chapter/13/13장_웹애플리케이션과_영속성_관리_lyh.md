**컨테이너 환경에서 JPA가 동작하는 내부방식을 이해**

스프링 컨테이너의 기본전략
- 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용합니다.
  - 트랜잭션 범위 == 영속성 컨텍스트 생존범위
  - 트랜잭션의 시작과 함께 영속성 컨텍스트가 생기고 끝날 때 종료됩니다.
- @Transactional
  - 어노테이션이 있으면 메서드를 실행하기 직전에 Spring의 트랜잭션 AOP가 먼저 동작합니다.
  (트랜잭션을 시작합니다==영속성 컨텍스트가 생깁니다)
  - 트랜잭션을 커밋하면 1) 영속성 컨텍스트가 플러스 된 후에 2) DB 트랜잭션을 커밋합니다.
  - 만약 예외가 발생하면 트랜잭션을 롤백하고 종료하며 이때는 플러시를 호출하지 않습니다. 
- 같은 트랜잭션 범위 안에서는 같은 영속성 컨텍스트를 사용합니다. 하지만 다른 트랜잭션을 사용하면 
- 다른 영속성 컨텍스트를 사용합니다.
- **뷰에서는 준영속 상태여서 지연 로딩 기능이 동작하지 않습니다.**
- 뷰를 렌더링할 때 엔티티를 지연로딩으로 설정해 프록시 객체로 조회했다고 가정하면
실제 데이터를 불려오려고 초기화를 시도하지만 준영속 상태는 영속성 컨텍스트가 없으므로
지연 로딩을 할 수 없어 `LazyInitializationException`이 발생합니다.
  - 해결방법: 
    1) 뷰가 필요한 엔티티를 미리 로딩
       - 영속성 컨텍스트가 살아있을 때 필요한 엔티티들을 미리 다 로딩하거나 초기화해서 반환하는 방법
    2) OSIV를 사용해 엔티티를 항상 영속 상태로 유지
- 뷰가 필요한 엔티티를 미리 로딩해두는 방법
  - 글로벌 페치 전략 수정
  - JPQL Fetch Join
  - 강제로 초기화
1) 글로벌 페치 전략 수정
   - FetchType.EAGER로 수정합니다. -> 원리를 이해못하겠음 왜 이렇게하면 되는건지??
   - `단점`: 사용하지 않는 엔티티도 로딩하며 N+1 문제가 발생합니다.
2) JPQL Fetch Join
   - 레포지토리에 페치 조인으로 조회하는 `findOrderWithMember()` 메서드를 추가해야 합니다.
   - 뷰와 레포지토리 간의 `논리적 의존관계`가 발생합니다.
3) 강제로 초기화
   - 지연 로딩으로 하면 프록시 객체로 조회하지만 조회한 엔티티를 실제 사용하면
   영속성 컨텍스트에 초기화 됩니다. 따라서 `orders.getMember()`로 끝내지 않고
   `orders.getMember().getName()`으로 `Member` 엔티티를 사용해줌으로써 강제 초기화를
   통해 영속성 컨텍스트를 생성해주는 방식입니다. 
   - 프록시 초기화 담당 `FACADE` 계층 추가
   ![image](https://user-images.githubusercontent.com/61368705/130351629-653cc5c9-ab33-4f98-af53-1c139efe7205.png)
        - 특징: 도메인 - 뷰 계층 간의 논리적 의존성을 분리해줍니다.
        - 서비스 계층을 호출해 비즈니스 로직을 실행시킵니다.
        - 레포지토리를 직접 호출해 뷰가 요구하는 엔티티를 찾습니다.
        - 단점: 중간에 계층이 하나 더 끼기 때문에 위임 코드가 많아집니다. 
4) 준영속 상태와 지연 로딩 정리 
   - 뷰를 개발할 때 필요한 엔티티를 미리 초기화하는 방법은 생각보다 오류가 많을 가능성이 높습니다.
   의존되어 있는 클래스들을 놓칠 수 있기 때문입니다.
   - 문제는 `엔티티가 프레젠테이션 계층에서 준영속 상태이기 때문에 발생합니다.`
   OSIV를 사용해 영속성 컨텍스트를 뷰까지 살아있게 열어두면 됩니다.
 
**OSIV(Open Session In View)**

**과거 OSIV**
- 클라이언트 요청이 들어오면 인터셉터에서 트랜잭션을 시작하고 요청이 끝날 때 트랜잭션도 끝냅니다.
aka. 요청 당 트랜잭션 방식
  ![image](https://user-images.githubusercontent.com/61368705/130352141-5d0f8bc6-4c91-4a29-b9d2-764f216bc42f.png)
- 하지만 뷰 계층에서 엔티티가 변경될수도 있다는 큰 문제점이 있습니다. 
  - 해결방법:
    1) 엔티티를 읽기 전용 인터페이스로 제공
    2) 엔티티 레핑
    3) DTO만 반환
  
  1) 엔티티를 읽기 전용 인터페이스로 제공
     - `MemberView` 인터페이스에 일기 전용 메서드만 구현합니다. `getName()`
  2) 엔티티 레핑
     - `Member` 엔티티를 감싸고있는 `MemberWrapper` 클래스를 만들어 읽기 전용 메서드만 구현합니다.
  3) DTO만 반환
     - 가장 전통적인 방법인데, 엔티티에 대응하는 DTO를 만들어 엔티티의 값을 채워 반환합니다. 

**스프링 OSIV**

**트랜잭션은 비즈니스 계층에서만 사용합니다.**

![image](https://user-images.githubusercontent.com/61368705/130352300-95e77856-f7bc-4aeb-8e91-b53dda096397.png)
- 트랜잭션은 서비스 계층에서만, 영속성 컨텍스트는 프레젠테이션 계층에 까지 오픈해줍니다.
- `Nontransactional reads`, 강제로 수정을 가해도 범위 밖이기 때문에 예외로 처리합니다.

**주의 사항**
- 프레젠테이션 계층에서 수정을 가하고 서비스 계층을 호출해 트랜잭션을 실행할 경우
    - 해결방법: 위와 같은 순서로 코드를 짜지 않습니다.
  ```java
    class MemberController {
        public String viewMember(Long id) {
            Member member = memberService.getMember(id);
            member.setName("XXX");
            
            memberService.biz();
            return "view";
        }
  }
  ```
  
**OSIV의 단점**
- 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있습니다. 특히 롤백 시 주의해야 합니다.
- 사용하지 않는 대안은 DTO를 만들어 반환하는 것입니다.
- OSIV를 사용하면 엔티티를 유지하면서 객체 그래프를 마음껏 탐색할 수 있습니다.
하지만 이는 복잡한 화면을 구성할 때 특히 적합하지 않으며 `JPQL + DTO`방식으로 조회하는 것이 효과적입니다.

